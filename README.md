AAtree
======
恒例の結城浩さんによるCodeIQ問題です。
今回は、記憶装置トリアニーの謎を解け！という問題でした。

問題の詳細はこちら http://gonshi.net/post/47849836250/aa

【プログラム概要】

本プログラムはJavaで記述されており、dictiとtlliの2つのクラスで構成される。

クラスdictiが技術ドキュメントにおけるDICTIの動作を、クラスtlliが技術ドキュメントにおけるTLLIの動作を行う。

クラスdictiのmain関数が辞書プログラムの動作を行う。つまり、テストデータを読み込んだのち、DICTIの関数set_entryとfind_entryのいずれかを呼び出すことによって辞書への挿入および検索を実現する。さらに、find_entryの戻り値の合計を計算し、testdataを全て読み込み終えた時点でそれを出力する。

DICTIの関数set_entryとfind_entryはTLLIを用いて実装されている。つまり、クラスdictiの関数set_entryとfind_entryはクラスtlliの関数(技術ドキュメントに記載されているTLLIの関数8つ)を呼び出すことでTrianyへのアクセスを行う。

【Trianyのデータ構造】

本プログラムでは、Trianyを用いたデータ構造として平衡2分探索木の1つであるAA木を採用した。その理由として以下が挙げられる。

・testdata内でkeyの値が昇順にソートされた一連の記述が一部で見られるため、通常の2分探索木では木の平衡性が崩れ、処理速度のパフォーマンスが低下してしまう。

・testdataのように挿入の多い入力データを考慮すると、平衡条件の厳しいAVL木では木の回転操作が多くなることで処理速度のパフォーマンスが低下してしまう可能性がある。

上記の理由から、赤黒木とAA木が有力なデータ構造の候補として残ったが、比較的簡潔なアルゴリズムで実現できるAA木を採用した。

技術ドキュメントの仕様上、1つのTrianyは3つの非負整数しか持つことができない。一方で、辞書を構成するAA木を1つの木で実現するには、1つのノード(Triany)が「キー」「値」「レベル(AA木の仕様上必要)」「右の子ノードのID」「左の子ノードのID」という5つの非負整数を持つ必要があるため、1つの木で辞書を構成するのは不可能である。そこで、本プログラムでは3つのAA木によって辞書を構成することとした。それぞれのAA木におけるノード(Triany)に格納されている情報は以下の通りである。

(1) a「キー」、b「左の子ノードのID」、c「右の子ノードのID」
(2) a「値」、b「左の子ノードのID」、c「右の子ノードのID」
(3) a「レベル」、b「左の子ノードのID」、c「右の子ノードのID」

この3つの木は常に同じ構造をしている。そして、(1)～(3)の木において同じ位置に存在しているノードのa値(キー、値、レベル)は対応関係を示す。

(例：(1)の木の根からたどって、右→左→右の位置に存在するノードの「キー」(aがもつ非負整数)に対応する「値」は、(2)の木の根からたどって、同じく右→左→右の位置に存在するノードのaがもつ非負整数である)

入力データから新たなエントリの挿入命令が与えられたとき、全ての木に対する新たなノードの挿入位置は(1)の木のa値「キー」を基準として探索され、木の回転は(3)の木のa値「レベル」を基準として行われる。つまり、エントリの挿入命令が与えられたとき、まず、(1)の木におけるa値「キー」を基準とした2分探索を行い、その探索結果位置に入力データの「キー」をa値に格納したノードを追加する。さらに、(2)の木には入力データの「値」をa値に格納したノードを、(3)の木には「1」をa値に格納したノードを(1)の木に挿入した位置と同じ位置に追加する。次に、(3)の木のa値「レベル」を基準としてAA木構造の妥当性チェックを行い、回転が必要な場合には(1)、(2)、(3)全ての木に対して同等の回転操作を行う。このようにAA木では木の回転が必要であるため、これを実行する関数としてrotateをクラスdictiに追加した。

AA木における木の回転については、「Algorithms with Python / AA 木 (Arne Andersson tree) http://www.geocities.jp/m_hiroi/light/pyalgo53.html」と「木の回転 - Wikipedia http://ja.wikipedia.org/wiki/%E6%9C%A8%E3%81%AE%E5%9B%9E%E8%BB%A2」を参考とした。


【その他】

本プログラムでは、平衡2分探索木の1つであるAA木を採用したことにより、挿入および検索の処理速度向上を図った。実際、技術ドキュメントに記載されているリスト構造で辞書を構成した場合と処理速度を比較した際、AA木の方が約1/9の実行時間で計算を終えることが確認できた(testdataを入力とした際)。

また、本プログラムではtlliというクラスのみによってTrianyの管理を行なっているため、上記のようにデータ構造の変更が容易である。つまり、クラスtlliを呼び出しているクラスdictiの関数set_entryとfind_entryの内容を変更するだけでデータ構造の変更を行うことができるため、拡張性に優れている。例えば本プログラムに対して、辞書のエントリを「削除」するという機能を加える場合にも、set_entryと辞書プログラムの内容に新たな記述を追加するだけで実現可能である。


